input {
	udp {
		port => 50014
		type => syslog
	}
}

filter {
	# cleanup message
	mutate {
	strip => "message"
	}
	# parse the syslog part
	grok {
		match => { "message" => "^<%{POSINT:syslog_pri}>%{TIMESTAMP_ISO8601:syslog_timestamp} %{DATA:syslog_host} docker/%{DATA:syslog_container}(?:\[%{POSINT:syslog_pid}\])?: (%{LOGLEVEL:app_loglevel} )?%{GREEDYDATA:syslog_message}?$" }
	}
	# transform the syslog priority to a string
	syslog_pri {
		severity_labels => ["EMERG", "ALERT", "CRIT", "ERROR", "WARNING", "NOTICE", "INFO", "DEBUG"]
	}
	# if the app sent a log level, use it to override the syslog one
	if [app_loglevel] {
		mutate {
			uppercase => [ "app_loglevel" ]
			replace => { "syslog_severity" => "%{app_loglevel}" }
		}
	}
}

output {
	stdout { codec => rubydebug }
	tcp {
		host => '0.0.0.0'
		port => '9090'
		mode => 'server'
	}
	if "_grokparsefailure" in [tags] {
		file {
			path => "/openstack/logs/grokparsefailure.log"
			message_format => "%{message}"
		}
	} else {
		file {
			path => "/openstack/logs/%{syslog_host}/%{syslog_container}.log"
			message_format => "%{syslog_timestamp} %{syslog_severity} %{syslog_host}/%{syslog_container}: %{syslog_message}"
		}
		file {
			path => "/openstack/logs/openstack.log"
			message_format => "%{syslog_timestamp} %{syslog_severity} %{syslog_host}/%{syslog_container}: %{syslog_message}"
		}
	}
}
